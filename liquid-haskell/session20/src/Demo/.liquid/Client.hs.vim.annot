1:1-1:1::Demo.Client.$trModule :: "GHC.Types.Module"
12:1-12:5::Demo.Client.bump :: "GHC.Types.Int -> GHC.Types.Int"
12:6-12:7::n :: "GHC.Types.Int"
12:13-12:14::n :: "{v : GHC.Types.Int | v == n}"
12:17-12:18::lq_anf$##7205759403792808873 :: "GHC.Types.Int"
12:24-12:30::Demo.Lib.incr :: "{v : GHC.Types.Int | 0 < v} -> {v : GHC.Types.Int | 0 < v}"
12:29-12:30::n :: "{v : GHC.Types.Int | v == n}"
12:36-12:37::lq_anf$##7205759403792808876 :: "{v : GHC.Prim.Int# | v == 0}"
18:1-18:5::Demo.Client.test :: "x1:Demo.Client.Simple -> {VV : (GHC.Maybe.Maybe GHC.Types.Bool) | VV == test x1}"
18:10-18:19::GHC.Maybe.Just :: "{VV : forall a .\n      x1:a -> {v : (GHC.Maybe.Maybe a) | v == Just x1\n                                         && lqdc##$select v == x1} | VV == Just}"
18:15-18:19::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
19:10-19:17::_ :: "{VV : forall a .\n      {v : (GHC.Maybe.Maybe a) | v == Nothing} | VV == Nothing}"
23:1-23:10::Demo.Client.testProof :: "{VV : () | test A == Just true}"
24:3-24:9::lq_anf$##7205759403792808844 :: "{v : (GHC.Maybe.Maybe GHC.Types.Bool) | v == test A}"
24:8-24:9::Demo.Client.A :: "{v : Demo.Client.Simple | v == A}"
24:14-24:23::lq_anf$##7205759403792808845 :: "{v : (GHC.Maybe.Maybe GHC.Types.Bool) | v == Just True\n                                        && lqdc##$select v == True}"
24:19-24:23::GHC.Types.True :: "{v : GHC.Types.Bool | v\n                      && v == True}"
25:7-25:10::Language.Haskell.Liquid.Equational.QED :: "{v : Language.Haskell.Liquid.Equational.QED | v == QED}"